#!/bin/bash
set -e

SKOL_HOME=/opt/skol
SKOL_VENV=${SKOL_HOME}/venv
PYTHON=python3.13

# Create skol group if it doesn't exist
if ! getent group skol > /dev/null 2>&1; then
    groupadd --system skol
    echo "Created group 'skol'"
fi

# Create skol user if it doesn't exist
if ! getent passwd skol > /dev/null 2>&1; then
    useradd --system --gid skol --home-dir ${SKOL_HOME} --shell /bin/false skol
    echo "Created user 'skol'"
fi

# Create /opt/skol directory structure
mkdir -p ${SKOL_HOME}/bin
mkdir -p ${SKOL_HOME}/data
mkdir -p ${SKOL_HOME}/models
chown -R skol:skol ${SKOL_HOME}
chmod 755 ${SKOL_HOME}

# Create log directory
mkdir -p /var/log/skol
chown skol:skol /var/log/skol
chmod 755 /var/log/skol

# Create Python virtual environment and install dependencies
echo "Creating Python 3.13 virtual environment at ${SKOL_VENV}..."
${PYTHON} -m venv ${SKOL_VENV}

echo "Upgrading pip..."
${SKOL_VENV}/bin/pip install --upgrade pip

echo "Installing all packages from local wheels..."
${SKOL_VENV}/bin/pip install ${SKOL_HOME}/wheels/*.whl

echo "Installing ML dependencies..."
${SKOL_VENV}/bin/pip install transformers accelerate huggingface-hub peft torch protobuf sentencepiece bitsandbytes

# Set ownership of venv to skol user
chown -R skol:skol ${SKOL_VENV}

# Create with_skol wrapper script that activates the venv
# When invoked via symlink, it runs the corresponding .py file
cat > ${SKOL_HOME}/bin/with_skol << 'EOF'
#!/bin/bash
# Wrapper script to run skol commands with proper environment
# Can be invoked directly: with_skol python script.py
# Or via symlink: if symlinked as 'foo', runs foo.py

. ~skol/.skol_env
export MAILTO
export COUCHDB_USER
export COUCHDB_PASSWORD
export COUCHDB_URL
export INGEST_DATABASE
export TAXON_DATABASE
export LOGDIR
export VERBOSITY

# Redis Configuration
export REDIS_HOST
export REDIS_PORT

# Email configuration
export EMAIL_HOST
export EMAIL_PORT
export EMAIL_HOST_USER
export EMAIL_HOST_PASSWORD
export EMAIL_USE_TLS
export DEFAULT_FROM_EMAIL

export SKOL_HOME=/opt/skol
export SKOL_DATA=/opt/skol/data
export SKOL_MODELS=/opt/skol/models
export VIRTUAL_ENV=/opt/skol/venv
export PATH="${VIRTUAL_ENV}/bin:${PATH}"
unset PYTHONHOME

# Add skol bin directory to Python path for imports
export PYTHONPATH="${SKOL_HOME}/bin:${PYTHONPATH}"

# PySpark 4.x requires Java 17+
# Find Java 17+ installation
for java_dir in /usr/lib/jvm/java-21-openjdk-amd64 /usr/lib/jvm/java-17-openjdk-amd64 /usr/lib/jvm/java-21-openjdk /usr/lib/jvm/java-17-openjdk; do
    if [ -d "$java_dir" ]; then
        export JAVA_HOME="$java_dir"
        export PATH="${JAVA_HOME}/bin:${PATH}"
        break
    fi
done

# Get the name this script was invoked as
SCRIPT_NAME=$(basename "$0")

# If invoked as 'with_skol', run the command as-is
if [ "$SCRIPT_NAME" = "with_skol" ]; then
    exec "$@"
else
    # Invoked via symlink - run the corresponding .py file
    exec python "${SKOL_HOME}/bin/${SCRIPT_NAME}.py" "$@"
fi
EOF
chmod 755 ${SKOL_HOME}/bin/with_skol
chown skol:skol ${SKOL_HOME}/bin/with_skol

# Create symlinks for each command in /opt/skol/bin
for cmd in ingest train_classifier predict_classifier extract_taxa_to_couchdb embed_taxa taxa_to_json; do
    ln -sf with_skol ${SKOL_HOME}/bin/${cmd}
done

# Set ownership of bin directory
chown -R skol:skol ${SKOL_HOME}/bin

echo "SKOL installation complete."
echo "Commands available in ${SKOL_HOME}/bin/:"
echo "  ingest, train_classifier, predict_classifier, extract_taxa_to_couchdb, embed_taxa, taxa_to_json"
echo "Or use: ${SKOL_HOME}/bin/with_skol <command>"

#DEBHELPER#

exit 0
