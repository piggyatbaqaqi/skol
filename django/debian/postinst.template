#!/bin/bash
set -e

# Version injected at build time
VERSION="__VERSION__"
INSTALL_DIR="/opt/skol/django-versions/${VERSION}"

SKOL_HOME=/opt/skol
SKOL_DJANGO_VENV=${SKOL_HOME}/django-venv
PYTHON=python3.13

# Symlink target
DJANGO_SYMLINK="${SKOL_HOME}/django"

# Create skol group if it doesn't exist
if ! getent group skol > /dev/null 2>&1; then
    groupadd --system skol
    echo "Created group 'skol'"
fi

# Create skol user if it doesn't exist
if ! getent passwd skol > /dev/null 2>&1; then
    useradd --system --gid skol --home-dir ${SKOL_HOME} --shell /bin/false skol
    echo "Created user 'skol'"
fi

# Create log directory
mkdir -p /var/log/skol
chown skol:skol /var/log/skol
chmod 755 /var/log/skol

# Create opt directory for skol (including bin for wrapper scripts)
mkdir -p ${SKOL_HOME}
mkdir -p ${SKOL_HOME}/bin
mkdir -p ${SKOL_HOME}/staticfiles
mkdir -p ${SKOL_HOME}/config
chown -R skol:skol ${SKOL_HOME}

# Migrate old non-versioned layout if needed (but don't switch yet)
if [ -d "$DJANGO_SYMLINK" ] && [ ! -L "$DJANGO_SYMLINK" ]; then
    BACKUP="${SKOL_HOME}/django.old-$(date +%Y%m%d%H%M%S)"
    mv "$DJANGO_SYMLINK" "$BACKUP"
    echo "Migrated old ${DJANGO_SYMLINK} to $BACKUP"
fi

# NOTE: Symlink switch is deferred until the end to minimize downtime
# The old version continues serving while we prepare the new one

# Create Python virtual environment for Django and install dependencies
echo "Creating Python 3.13 virtual environment at ${SKOL_DJANGO_VENV}..."
${PYTHON} -m venv ${SKOL_DJANGO_VENV}

echo "Upgrading pip..."
${SKOL_DJANGO_VENV}/bin/pip install --upgrade pip

echo "Installing all packages from local wheels..."
${SKOL_DJANGO_VENV}/bin/pip install ${SKOL_HOME}/wheels/*.whl

# Set ownership of venv to skol user
chown -R skol:skol ${SKOL_DJANGO_VENV}

# Create with_skol_django wrapper script in the persistent venv bin directory
# Note: /opt/skol/bin is a symlink to versioned skol package, so we use django-venv/bin
WRAPPER_PATH="${SKOL_DJANGO_VENV}/bin/with_skol_django"
cat > "$WRAPPER_PATH" << 'EOF'
#!/bin/bash
# Wrapper script to run skol-django commands with proper environment
export SKOL_HOME=/opt/skol
export SKOL_DATA=/opt/skol/data
export SKOL_MODELS=/opt/skol/models
export SKOL_DJANGO_ROOT=/opt/skol/django
export VIRTUAL_ENV=/opt/skol/django-venv
export PATH="${VIRTUAL_ENV}/bin:${PATH}"
# CRITICAL: Add SKOL_DJANGO_ROOT to PYTHONPATH so Python imports the deployed
# version of skolweb instead of the one in site-packages from the wheel
export PYTHONPATH="${SKOL_DJANGO_ROOT}:${PYTHONPATH}"
export DJANGO_SETTINGS_MODULE=skolweb.settings
unset PYTHONHOME
exec "$@"
EOF
chmod 755 "$WRAPPER_PATH"
chown skol:skol "$WRAPPER_PATH"

# Create a temporary wrapper that points to the NEW version for setup tasks
# This allows migrations/collectstatic to run against the new code
TEMP_WRAPPER="${SKOL_DJANGO_VENV}/bin/with_skol_django_new"
cat > "$TEMP_WRAPPER" << EOF
#!/bin/bash
export SKOL_HOME=/opt/skol
export SKOL_DATA=/opt/skol/data
export SKOL_MODELS=/opt/skol/models
export SKOL_DJANGO_ROOT=${INSTALL_DIR}
export VIRTUAL_ENV=/opt/skol/django-venv
export PATH="\${VIRTUAL_ENV}/bin:\${PATH}"
# CRITICAL: Add SKOL_DJANGO_ROOT to PYTHONPATH so Python imports the deployed
# version of skolweb instead of the one in site-packages from the wheel
export PYTHONPATH="\${SKOL_DJANGO_ROOT}:\${PYTHONPATH}"
export DJANGO_SETTINGS_MODULE=skolweb.settings
unset PYTHONHOME
exec "\$@"
EOF
chmod 755 "$TEMP_WRAPPER"
chown skol:skol "$TEMP_WRAPPER"

# Create shared config directory
mkdir -p ${SKOL_HOME}/config
chown skol:skol ${SKOL_HOME}/config

# Config file location (shared across versions)
CONFIG_FILE="${SKOL_HOME}/config/skol-django.env"

# Migrate config from old version-specific location if needed
if [ ! -f "$CONFIG_FILE" ]; then
    # Check for config in current version directory (old layout)
    if [ -L "$DJANGO_SYMLINK" ] && [ -f "${DJANGO_SYMLINK}/skol-django.env" ]; then
        echo "Migrating config from ${DJANGO_SYMLINK}/skol-django.env to shared location..."
        cp "${DJANGO_SYMLINK}/skol-django.env" "$CONFIG_FILE"
    # Check for config in new version directory (shouldn't exist, but just in case)
    elif [ -f "${INSTALL_DIR}/skol-django.env" ]; then
        echo "Migrating config from ${INSTALL_DIR}/skol-django.env to shared location..."
        cp "${INSTALL_DIR}/skol-django.env" "$CONFIG_FILE"
    else
        # Create default config file
        echo "Creating default config at $CONFIG_FILE..."
        cat > "$CONFIG_FILE" << 'ENVEOF'
# SKOL Django Environment Configuration
# This file persists across version upgrades
# Edit this file to customize the Django environment

# URL path prefix when running at a subpath (e.g., /skol)
# Set to empty if running at the root of a domain
FORCE_SCRIPT_NAME=/skol

# Set to True when running behind HTTPS reverse proxy
SKOL_HTTPS=False

# Comma-separated list of trusted origins for CSRF protection
# Example: https://skol.example.com,https://www.skol.example.com
CSRF_TRUSTED_ORIGINS=

# Redis configuration
REDIS_HOST=localhost
REDIS_PORT=6379

# CouchDB configuration for PDF attachment retrieval
COUCHDB_HOST=localhost
COUCHDB_PORT=5984
COUCHDB_USER=admin
COUCHDB_PASSWORD=
# Optionally set COUCHDB_URL to override host:port
# COUCHDB_URL=http://localhost:5984

# PostgreSQL configuration (optional - uses SQLite by default)
# To use PostgreSQL, uncomment and configure POSTGRES_HOST
# POSTGRES_HOST=localhost
# POSTGRES_PORT=5432
# POSTGRES_DB=skol
# POSTGRES_USER=skol
# POSTGRES_PASSWORD=
ENVEOF
    fi
else
    echo "Preserving existing config at $CONFIG_FILE"
fi
chown skol:skol "$CONFIG_FILE"
chmod 640 "$CONFIG_FILE"

# Create shared data directory for SQLite database
DJANGO_DATA_DIR="${SKOL_HOME}/data/django"
mkdir -p "$DJANGO_DATA_DIR"
chown skol:skol "$DJANGO_DATA_DIR"

# Migrate database from version-specific location if needed
SHARED_DB="${DJANGO_DATA_DIR}/db.sqlite3"
if [ ! -f "$SHARED_DB" ]; then
    # Check for database in current version directory (via symlink)
    if [ -L "$DJANGO_SYMLINK" ] && [ -f "${DJANGO_SYMLINK}/db.sqlite3" ]; then
        echo "Migrating database from ${DJANGO_SYMLINK}/db.sqlite3 to shared location..."
        cp "${DJANGO_SYMLINK}/db.sqlite3" "$SHARED_DB"
        chown skol:skol "$SHARED_DB"
        echo "Database migrated to $SHARED_DB"
    # Check for database in any previous version directory
    elif [ -d "${SKOL_HOME}/django-versions" ]; then
        # Find the most recent db.sqlite3 from any version
        LATEST_DB=$(find "${SKOL_HOME}/django-versions" -name "db.sqlite3" -type f -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | cut -d' ' -f2-)
        if [ -n "$LATEST_DB" ] && [ -f "$LATEST_DB" ]; then
            echo "Migrating database from $LATEST_DB to shared location..."
            cp "$LATEST_DB" "$SHARED_DB"
            chown skol:skol "$SHARED_DB"
            echo "Database migrated to $SHARED_DB"
        fi
    fi
else
    echo "Using existing database at $SHARED_DB"
fi

# Run database migrations against the NEW version
echo "Running database migrations..."
cd ${INSTALL_DIR}
sudo -u skol ${SKOL_DJANGO_VENV}/bin/with_skol_django_new python manage.py migrate --noinput
echo "Database migrations complete."

# Collect static files from the NEW version
echo "Collecting static files..."
sudo -u skol ${SKOL_DJANGO_VENV}/bin/with_skol_django_new python manage.py collectstatic --noinput
echo "Static files collected."

# Clean up temporary wrapper
rm -f ${SKOL_DJANGO_VENV}/bin/with_skol_django_new

# Set ownership and permissions of the new version directory
chown -R skol:skol ${INSTALL_DIR}
# Ensure files are readable (directories 755, files 644, preserve execute bit)
find ${INSTALL_DIR} -type d -exec chmod 755 {} \;
find ${INSTALL_DIR} -type f -exec chmod 644 {} \;
chmod 755 ${INSTALL_DIR}/manage.py

# ============================================================
# ATOMIC SWITCH: Now that everything is ready, switch symlink
# ============================================================
echo "Switching to new version..."
ln -sfn "$INSTALL_DIR" "$DJANGO_SYMLINK"
echo "Activated skol-django ${VERSION}"

# Install systemd service and restart
if [ -d /run/systemd/system ]; then
    cp /usr/share/skol-django/skol-django.service /etc/systemd/system/
    systemctl daemon-reload
    systemctl enable skol-django.service
    # Restart service if it was already running (upgrade case)
    if systemctl is-active --quiet skol-django.service; then
        echo "Restarting SKOL Django service..."
        systemctl restart skol-django.service
    else
        echo "SKOL Django service installed. Start with: systemctl start skol-django"
    fi
fi

echo "SKOL Django ${VERSION} installation complete."
echo "Use '/opt/skol/django-venv/bin/with_skol_django <command>' to run django commands."
echo ""
echo "Version rollback: skol-switch-version django <version>"
echo "Available versions: ls /opt/skol/django-versions/"

#DEBHELPER#

exit 0
